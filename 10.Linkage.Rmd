---
title: "Aedes aegypti Brazil - Linkage."
author: "Luciano V Cosme"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: breezedark
    css:
      - "styles.css"
    toc: yes
    toc_float: no
    toc_depth: 5
editor_options:
  markdown:
    wrap: 120
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval                        = TRUE,
  echo                        = TRUE,
  cache                       = TRUE, # tidy = TRUE,
  class.output                = "bg-success"
)
knitr::opts_knit$set(
  root.dir = rprojroot::find_rstudio_root_file()
)
```

<span class="rainbow-title">Analysis code</span>

<!-- Custom JavaScript to apply the rainbow effect to the title -->
<script>
document.addEventListener("DOMContentLoaded", function() {
  var titleElements = document.querySelectorAll('h1');
  if (titleElements.length > 0) {
    titleElements[0].classList.add('rainbow-title');
  }
});
</script>


## 1. R libraries and software

```{r libraries, message=FALSE, results='hide'}
library(tidyverse)
library(here)
library(dplyr)
library(ggplot2)
library(colorout)
library(extrafont)
library(scales)
library(stringr)
library(flextable)
library(officer)
library(ggtext)
library(RColorBrewer)
library(ggrepel)
library(grid)
library(forcats)
```

I will use the PopLDdecay for the estimates

https://github.com/BGI-shenzhen/PopLDdecay and the manuscript DOI:10.1093/bioinformatics/bty875

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```

## 2. Linkage patterns for the entire genome

I created a scale by merging the scaffolds according to the AalbF3 genome assembly.

NOTE: PopLDdecay will estimate linkage across chromosomes. Check the files it creates and you will see that it merge the chromosomes. When we use the scaffolds, it merge them numerically and it is not in the order that AalbF3 genome assembly sets. That is why there is differences betweem them and the chromosomal level estimates.

Create file before filtering removing the related individuals and populations from previous study
```{bash}
plink2 \
--allow-extra-chr \
--bfile output/populations/file6 \
--remove-fam output/populations/families_2_remove.txt \
--make-bed \
--out output/populations/PopLDdecay/fileLD1 \
--silent;
 grep 'samples\|variants\|remaining' output/populations/PopLDdecay/fileLD1.log
```

Remove the family TER because it has only 2 individuals
```{bash}
echo "TER" > output/populations/PopLDdecay/ter.txt
```


Create vcf (using the defaul MAF threshold of PopLDdecay)
```{bash}
# Convert the entire bfile to VCF without splitting by population
plink2 \
--remove-fam output/populations/PopLDdecay/ter.txt \
--bfile output/populations/PopLDdecay/fileLD1 \
--maf 0.005 \
--make-bed \
--recode vcf \
--out output/populations/PopLDdecay/fileLD12 \
--geno 0.2 \
--silent

# Remove unwanted files, if needed
head -n100 output/populations/PopLDdecay/fileLD12.log
```

Check samples
```{bash}
bcftools query -l output/populations/PopLDdecay/fileLD12.vcf | head
```

```{bash, eval=FALSE}
PopLDdecay --help
```

Get the files to run PopLDdecay
```{bash}
bcftools query -l output/populations/PopLDdecay/fileLD12.vcf > output/populations/PopLDdecay/vcf_samples.txt;

bcftools query -l output/populations/PopLDdecay/fileLD12.vcf | cut -d'_' -f1 | sort | uniq > output/populations/PopLDdecay/unique_pops_from_vcf.txt
while read pop; do
    grep "^${pop}_" output/populations/PopLDdecay/vcf_samples.txt > output/populations/PopLDdecay/${pop}_samples.txt
done < output/populations/PopLDdecay/unique_pops_from_vcf.txt
```


### 2.1 run PopLDdecay

Type 4 (estimates r2, d' and number SNPs per bin)

[-OutType 4] will OutPut the Stat (Dist ~ r^2 & D' ~ Number) result for R^2 & D' MeanBin/HW/MedianBin/PercentileBin plot
```{bash, eval=FALSE}
while read pop; do
    PopLDdecay -InVCF output/populations/PopLDdecay/fileLD12.vcf \
               -OutType 4 \
               -MaxDist 1000 \
               -MAF 0.005 \
               -OutFilterSNP \
               -OutStat output/populations/PopLDdecay/${pop}_LDdecay.4.gz \
               -SubPop output/populations/PopLDdecay/${pop}_samples.txt
done < output/populations/PopLDdecay/unique_pops_from_vcf.txt
```

Check the bin dir
```{bash}
ls /Users/lucianocosme/Packages/PopLDdecay/bin/
```

```{bash}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_OnePop.pl --help
```

For one pop type 4
```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_OnePop.pl \
-inFile output/populations/PopLDdecay/ARA_LDdecay.4.stat.gz \
-output output/populations/PopLDdecay/ARA_4 \
-bin1 10 \
-bin2 100 \
-break 100 \
-maxX 300 \
-measure r2 \
-method MeanBin \
-percent 0.5 \
-keepR
```


### 2.1 Plot using PopLDdecay - 1 plot per populations

First we can plot one population to fine tune the parameters
```{bash, eval=FALSE}
# Loop through all the LDdecay files
for file in output/populations/PopLDdecay/*_LDdecay.4.stat.gz; do
  # Extract the population name from the file name
  pop_name=$(basename "$file" _LDdecay.4.stat.gz)
  
  # Run the Plot_OnePop.pl script for each file
  perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_OnePop.pl \
    -inFile "$file" \
    -output "output/populations/PopLDdecay/$pop_name" \
    -bin1 100 \
    -bin2 1000 \
    -break 200 \
    -maxX 300 \
    -measure r2 \
    -keepR
done
```

Check the help for plotting

```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_MultiPop.pl --help
```


Create the files we need
```{bash, eval=FALSE}
for file in output/populations/PopLDdecay/*_LDdecay.4.stat.gz; do 
    pop_name=$(basename $file _LDdecay.4.stat.gz)
    echo "$file    $pop_name"
done > output/populations/PopLDdecay/ld_decay_results_list.txt

head -100 output/populations/PopLDdecay/ld_decay_results_list.txt
```

### 2.1 Plot using PopLDdecay - 1 plot all populations

For type 4 - all populations in one plot
```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_MultiPop.pl \
      -in output/populations/PopLDdecay/ld_decay_results_list.txt \
      -output output/populations/PopLDdecay/all_pops \
      -bin1 100 \
      -bin2 1000 \
      -break 200 \
      -maxX 300 \
      -measure r2 \
      -method MeanBin \
      -keepR
```

### 2.1 Plot using ggplot

Remember this is "merging" the chromosomes and estimating linkage between them as well. We get higher estimates. Perhaps indicate some problems with the genome assembly 
```{r, fig.height=6, fig.width=8}
# Define the path to the .fam file using here
fam_file_path <- here("output", "populations", "PopLDdecay", "fileLD12.fam")

# Read the .fam file
fam_data <- read.table(fam_file_path, header = FALSE, stringsAsFactors = FALSE)

# Extract the family names from the first column
populations <- unique(fam_data$V1)

# Remove "TER" from the populations vector
# populations <- populations[populations != "TER"]

# Determine the number of unique populations
num_populations <- length(unique(populations))

# Fetch colors accordingly
colors_set3 <- brewer.pal(min(12, num_populations), "Set3")
colors_pastel2 <- brewer.pal(min(8, num_populations - length(colors_set3)), "Pastel2")
colors_paired <- brewer.pal(min(12, num_populations - length(colors_set3) - length(colors_pastel2)), "Paired")

# Combine the colors
colors <- c(colors_set3, colors_pastel2, colors_paired)

# Ensure we're only taking as many colors as there are populations
colors <- colors[1:num_populations]

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)


# Initialize an empty list to store data frames
data_frames <- list()

#
# Read data from each population file and store it in the list
for (pop in populations) {
  file_path <- paste("output/populations/PopLDdecay/all_pops.", pop, sep = "")
  data <- read.table(file_path)
  data$population <- pop  # Add a column for population name
  data_frames[[pop]] <- data
}

# Combine all data frames into a single data frame
combined_data <- do.call(rbind, data_frames)

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)


# Create a ggplot2 plot with adjusted line thickness and colors
p <- ggplot(combined_data, aes(x = V1 / 1000, y = V2, group = population, color = population)) +
  # geom_line(size = .3) +  # If you want to add the line back, you can uncomment this line
  geom_point(size = .3, alpha = 0.2) +
  geom_smooth(method = "loess", se = FALSE, span = 0.2) +  # Adding the loess curve
  scale_color_manual(values = color_mapping) +  # Using the custom colors
  labs(
    title = "LD decay",
    x = "Distance(Kb)",
    y = expression(r^2)
  ) +
  theme_minimal() +
  theme(legend.position = "top") +
  coord_cartesian(xlim = c(0, 300))

p
# Save the plot as a PDF
# ggsave("output/populations/PopLDdecay/all_pops_ggplot.pdf", plot = p, width = 8, height = 6)

```


Annotate the half distance of maximum r2 on the facet plot
```{r, fig.height=10, fig.width=10}
# Calculate half distances
half_distances <- combined_data |>
  group_by(population) |>
  mutate(max_r2 = max(V2)) |>
  filter(V2 <= max_r2 / 2) |>
  arrange(V1) |>
  slice(1) |>
  select(population, half_distance = V1)

#
# Calculate the maximum V2 value for each population
max_values <- combined_data |>
  group_by(population) |>
  summarize(max_V2 = max(V2))

# Merge the maximum V2 values with the half_distances dataframe
half_distances <- merge(half_distances, max_values, by = "population")


# Create the ggplot
p <- ggplot(combined_data, aes(x = V1 / 1000, y = V2, group = population, color = population)) +
  geom_point(size = .3, alpha = 0.1) +
  geom_smooth(method = "loess", se = FALSE, span = 0.3, color = "black", linewidth = 0.5) +
  geom_vline(data = half_distances, aes(xintercept = half_distance / 1000), color = "blue", linetype = "dashed") +

  geom_text_repel(data = half_distances, aes(x = half_distance / 1000 + 135, y = max_V2, label = paste0(round(half_distance / 1000, 1), "Kb")), 
            color = "blue", vjust = -1, size = 3) +
  
  labs(
    title = "",
    x = "Distance(Kb)",
    y = expression(r^2)
  ) +
  scale_color_manual(values = color_mapping) +
  scale_y_continuous(labels = label_comma(accuracy = 0.01)) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(face = "bold", size = 14),
    axis.title.y = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  ) +
  facet_wrap(~ population, scales = "free_y", ncol = 3) +
  coord_cartesian(xlim = c(0, 1000))

p

# ggsave("output/populations/PopLDdecay/all_pops_facet_ggplot_chr.pdf", plot = p, width = 5, height = 8)
```

Save the data to use later
```{r}
saveRDS(combined_data, here(
  "output", "populations", "PopLDdecay", "genome.rds"
))
```


## 2. Chromosomal level LD estimates

We will use MAF 1% for each chromosome. We used 5% for the entire data set to reduce to computational time and find general patterns. The MAF threshold impacts the estimates.
Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


We can estimate LD for each chromosome separated.

Import the .bim file with the SNPs to create a new chromosomal scale.

```{r}
#   ____________________________________________________________________________
#   import the bim file with the SNP data                                   ####
snps <-
  read_delim(                    # to learn about the options use here, run ?read_delim on the console.
    here(
      "output", "populations", "PopLDdecay", "fileLD12.bim"
    ),                           # use library here to load it
    col_names      = FALSE,      # we don't have header in the input file
    show_col_types = FALSE,      # suppress message from read_delim
    col_types      = "ccidcc"    # set the class of each column
  )
#
# set column names
colnames(
  snps
) <-                             # to add a header in our tibble
  c(
    "Chromosome", "SNP", "Cm", "Position", "Allele1", "Allele2"
  )
#
# check the tibble
head(snps)
```

Separate the tibbles into each chromosome.

```{r}
#   ____________________________________________________________________________
#   separate the SNP data per chromosome                                    ####
# chr1
chr1_snps <-
  snps |>
  filter(Chromosome == 1) |> # here we get only Scaffold rows starting with 1
  as_tibble() # save as tibble
#
# chr2
chr2_snps <-
  snps |>
  filter(Chromosome == 2) |>
  as_tibble()
#
# chr3
chr3_snps <-
  snps |>
  filter(Chromosome == 3) |>
  as_tibble()
```


We have objects with the SNPs for each chromosome

```{r}
head(chr1_snps)
```

Filter the data by chromosome

Chromosome 1
```{r}
write.table(
  chr1_snps$SNP,
  file      = here(
    "output", "populations", "PopLDdecay","chr1_ld_SNPs.txt"
  ),
  sep       = "\t",
  row.names = FALSE,
  col.names = FALSE,
  quote     = FALSE
)
```

Chromosome 2
```{r}
write.table(
  chr2_snps$SNP,
  file      = here(
    "output", "populations", "PopLDdecay", "chr2_ld_SNPs.txt"
  ),
  sep       = "\t",
  row.names = FALSE,
  col.names = FALSE,
  quote     = FALSE
)
```

Chromosome 3
```{r}
write.table(
  chr3_snps$SNP,
  file      = here(
    "output", "populations", "PopLDdecay", "chr3_ld_SNPs.txt"
  ),
  sep       = "\t",
  row.names = FALSE,
  col.names = FALSE,
  quote     = FALSE
)
```

Now create new files for each chromosome

Chromosome 1

```{bash}
plink2 \
--bfile output/populations/PopLDdecay/fileLD12 \
--extract output/populations/PopLDdecay/chr1_ld_SNPs.txt \
--make-bed \
--export vcf \
--out output/populations/PopLDdecay/chr1_ld \
--silent;
grep 'samples\|variants\|remaining' output/populations/PopLDdecay/chr1_ld.log
```

Chromosome 2

```{bash}
plink2 \
--bfile output/populations/PopLDdecay/fileLD12 \
--extract output/populations/PopLDdecay/chr2_ld_SNPs.txt \
--make-bed \
--export vcf \
--out output/populations/PopLDdecay/chr2_ld \
--silent;
grep 'samples\|variants\|remaining' output/populations/PopLDdecay/chr2_ld.log
```

Chromosome 3

```{bash}
plink2 \
--bfile output/populations/PopLDdecay/fileLD12 \
--extract output/populations/PopLDdecay/chr3_ld_SNPs.txt \
--make-bed \
--export vcf \
--out output/populations/PopLDdecay/chr3_ld \
--silent;
grep 'samples\|variants\|remaining' output/populations/PopLDdecay/chr3_ld.log
```

Create dirs
```{bash, eval=FALSE}
# make directory
mkdir -p output/populations/ld_chr1;
mkdir -p output/populations/ld_chr2;
mkdir -p output/populations/ld_chr3;
```

Check the vcfs
```{bash}
ls output/populations/PopLDdecay/chr*_ld.vcf
```


### 2.1 Chromosome 1

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```

#### 2.1.1 run PopLDdecay

```{bash, eval=FALSE}
while read pop; do
    PopLDdecay -InVCF output/populations/PopLDdecay/chr1_ld.vcf \
               -OutType 4 \
               -MaxDist 1000 \
               -MAF 0.005 \
               -OutFilterSNP \
               -OutStat output/populations/ld_chr1/${pop}_LDdecay.gz \
               -SubPop output/populations/PopLDdecay/${pop}_samples.txt
done < output/populations/PopLDdecay/unique_pops_from_vcf.txt
```

#### 2.1.2 Plot using PopLDdecay

Get the files we need
```{bash, eval=FALSE}
for file in output/populations/ld_chr1/*_LDdecay.stat.gz; do 
    pop_name=$(basename $file _LDdecay.stat.gz)
    echo "$file    $pop_name"
done > output/populations/ld_chr1/ld_decay_results_list.txt

head -100 output/populations/ld_chr1/ld_decay_results_list.txt
```

Plot using PopLDdecay. It will create files that we can use to plot with ggplot

```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_MultiPop.pl \
      -in output/populations/ld_chr1/ld_decay_results_list.txt \
      -output output/populations/ld_chr1/all_pops \
      -bin1 100 \
      -bin2 1000 \
      -break 200 \
      -maxX 300 \
      -measure r2 \
      -method MeanBin \
      -keepR
```


#### 2.1.3 Plot using ggplot

```{r, fig.height=14, fig.width=10}
# Define the path to the .fam file using here
fam_file_path <- here("output", "populations", "PopLDdecay", "fileLD12.fam")

# Read the .fam file
fam_data <- read.table(fam_file_path, header = FALSE, stringsAsFactors = FALSE)

# Extract the family names from the first column
populations <- unique(fam_data$V1)

# Remove "TER" from the populations vector
# populations <- populations[populations != "TER"]

# Determine the number of unique populations
num_populations <- length(unique(populations))

# Fetch colors accordingly
colors_set3 <- brewer.pal(min(12, num_populations), "Set3")
colors_pastel2 <- brewer.pal(min(8, num_populations - length(colors_set3)), "Pastel2")
colors_paired <- brewer.pal(min(12, num_populations - length(colors_set3) - length(colors_pastel2)), "Paired")

# Combine the colors
colors <- c(colors_set3, colors_pastel2, colors_paired)

# Ensure we're only taking as many colors as there are populations
colors <- colors[1:num_populations]

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)


# Initialize an empty list to store data frames
data_frames <- list()

#
# Read data from each population file and store it in the list
for (pop in populations) {
  file_path <- paste("output/populations/ld_chr1/all_pops.", pop, sep = "")
  data <- read.table(file_path)
  data$population <- pop  # Add a column for population name
  data_frames[[pop]] <- data
}

# Combine all data frames into a single data frame
combined_data <- do.call(rbind, data_frames)

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)

# Calculate half distances
half_distances <- combined_data |>
  group_by(population) |>
  mutate(max_r2 = max(V2)) |>
  filter(V2 <= max_r2 / 2) |>
  arrange(V1) |>
  slice(1) |>
  select(population, half_distance = V1)

# Calculate the maximum V2 value for each population
max_values <- combined_data |>
  group_by(population) |>
  summarize(max_V2 = max(V2))

# Merge the maximum V2 values with the half_distances dataframe
half_distances <- merge(half_distances, max_values, by = "population")

# Create the ggplot
p <- ggplot(combined_data, aes(x = V1 / 1000, y = V2, group = population, color = population)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, span = 0.3, color = "black", linewidth = 0.5) +
  geom_vline(data = half_distances, aes(xintercept = half_distance / 1000), color = "blue", linetype = "dashed") +
  geom_text_repel(data = half_distances, aes(x = half_distance / 1000 + 130, y = max_V2, label = paste0(round(half_distance / 1000, 1), "Kb")), 
            color = "blue", vjust = -1, size = 3) +
  labs(
    title = "",
    x = "Distance(Kb)",
    y = expression(r^2)
  ) +
  scale_color_manual(values = color_mapping) +
  scale_y_continuous(labels = label_comma(accuracy = 0.01)) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(face = "bold", size = 14),
    axis.title.y = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  ) +
  facet_wrap(~ population, scales = "free_y", ncol = 3) +
  coord_cartesian(xlim = c(0, 300))

p

ggsave("output/populations/ld_chr1/decay_chr1.pdf", plot = p, width = 6, height = 10)
```

Save the data to use later
```{r}
saveRDS(combined_data, here(
  "output", "populations", "ld_chr1", "chr1.rds"
))
```


### 2.2 Chromosome 2

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


#### 2.2.1 run PopLDdecay

```{bash, eval=FALSE}
while read pop; do
    PopLDdecay -InVCF output/populations/PopLDdecay/chr2_ld.vcf \
               -OutType 4 \
               -MaxDist 1000 \
               -MAF 0.01 \
               -OutFilterSNP \
               -OutStat output/populations/ld_chr2/${pop}_LDdecay.gz \
               -SubPop output/populations/PopLDdecay/${pop}_samples.txt
done < output/populations/PopLDdecay/unique_pops_from_vcf.txt
```

#### 2.2.2 Plot using PopLDdecay

Get the files we need
```{bash, eval=FALSE}
for file in output/populations/ld_chr2/*_LDdecay.stat.gz; do 
    pop_name=$(basename $file _LDdecay.stat.gz)
    echo "$file    $pop_name"
done > output/populations/ld_chr2/ld_decay_results_list.txt

head -100 output/populations/ld_chr2/ld_decay_results_list.txt
```

Plot using PopLDdecay. It will create files that we can use to plot with ggplot

```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_MultiPop.pl \
      -in output/populations/ld_chr2/ld_decay_results_list.txt \
      -output output/populations/ld_chr2/all_pops \
      -bin1 100 \
      -bin2 1000 \
      -break 200 \
      -maxX 300 \
      -measure r2 \
      -method MeanBin \
      -keepR
```


#### 2.2.3 Plot using ggplot

```{r, fig.height=12, fig.width=10}
# Define the path to the .fam file using here
fam_file_path <- here("output", "populations", "PopLDdecay", "fileLD12.fam")

# Read the .fam file
fam_data <- read.table(fam_file_path, header = FALSE, stringsAsFactors = FALSE)

# Extract the family names from the first column
populations <- unique(fam_data$V1)

# Remove "TER" from the populations vector
# populations <- populations[populations != "TER"]

# Determine the number of unique populations
num_populations <- length(unique(populations))

# Fetch colors accordingly
colors_set3 <- brewer.pal(min(12, num_populations), "Set3")
colors_pastel2 <- brewer.pal(min(8, num_populations - length(colors_set3)), "Pastel2")
colors_paired <- brewer.pal(min(12, num_populations - length(colors_set3) - length(colors_pastel2)), "Paired")

# Combine the colors
colors <- c(colors_set3, colors_pastel2, colors_paired)

# Ensure we're only taking as many colors as there are populations
colors <- colors[1:num_populations]

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)


# Initialize an empty list to store data frames
data_frames <- list()

#
# Read data from each population file and store it in the list
for (pop in populations) {
  file_path <- paste("output/populations/ld_chr2/all_pops.", pop, sep = "")
  data <- read.table(file_path)
  data$population <- pop  # Add a column for population name
  data_frames[[pop]] <- data
}

# Combine all data frames into a single data frame
combined_data <- do.call(rbind, data_frames)

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)

# Calculate half distances
half_distances <- combined_data |>
  group_by(population) |>
  mutate(max_r2 = max(V2)) |>
  filter(V2 <= max_r2 / 2) |>
  arrange(V1) |>
  slice(1) |>
  select(population, half_distance = V1)

# Calculate the maximum V2 value for each population
max_values <- combined_data |>
  group_by(population) |>
  summarize(max_V2 = max(V2))

# Merge the maximum V2 values with the half_distances dataframe
half_distances <- merge(half_distances, max_values, by = "population")

# Create the ggplot
p <- ggplot(combined_data, aes(x = V1 / 1000, y = V2, group = population, color = population)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, span = 0.3, color = "black", linewidth = 0.5) +
  geom_vline(data = half_distances, aes(xintercept = half_distance / 1000), color = "blue", linetype = "dashed") +
  geom_text_repel(data = half_distances, aes(x = half_distance / 1000 + 130, y = max_V2, label = paste0(round(half_distance / 1000, 1), "Kb")), 
            color = "blue", vjust = -1, size = 3) +
  labs(
    title = "",
    x = "Distance(Kb)",
    y = expression(r^2)
  ) +
  scale_color_manual(values = color_mapping) +
  scale_y_continuous(labels = label_comma(accuracy = 0.01)) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(face = "bold", size = 14),
    axis.title.y = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  ) +
  facet_wrap(~ population, scales = "free_y", ncol = 3) +
  coord_cartesian(xlim = c(0, 300))

p

ggsave("output/populations/ld_chr1/decay_chr2.pdf", plot = p, width = 6, height = 10)
```

Save the data to use later
```{r}
saveRDS(combined_data, here(
  "output", "populations", "ld_chr2", "chr2.rds"
))
```


### 2.3 Chromosome 3

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```


#### 2.2.1 run PopLDdecay

```{bash, eval=FALSE}
while read pop; do
    PopLDdecay -InVCF output/populations/PopLDdecay/chr3_ld.vcf \
               -OutType 4 \
               -MaxDist 1000 \
               -MAF 0.005 \
               -OutFilterSNP \
               -OutStat output/populations/ld_chr3/${pop}_LDdecay.gz \
               -SubPop output/populations/PopLDdecay/${pop}_samples.txt
done < output/populations/PopLDdecay/unique_pops_from_vcf.txt
```

#### 2.2.2 Plot using PopLDdecay

Get the files we need
```{bash, eval=FALSE}
for file in output/populations/ld_chr3/*_LDdecay.stat.gz; do 
    pop_name=$(basename $file _LDdecay.stat.gz)
    echo "$file    $pop_name"
done > output/populations/ld_chr3/ld_decay_results_list.txt

head -100 output/populations/ld_chr3/ld_decay_results_list.txt
```

Plot using PopLDdecay. It will create files that we can use to plot with ggplot

```{bash, eval=FALSE}
perl /Users/lucianocosme/Packages/PopLDdecay/bin/Plot_MultiPop.pl \
      -in output/populations/ld_chr3/ld_decay_results_list.txt \
      -output output/populations/ld_chr3/all_pops \
      -bin1 100 \
      -bin2 1000 \
      -break 200 \
      -maxX 300 \
      -measure r2 \
      -method MeanBin \
      -keepR
```


#### 3.2.3 Plot using ggplot

```{r, fig.height=12, fig.width=10}
# Define the path to the .fam file using here
fam_file_path <- here("output", "populations", "PopLDdecay", "fileLD12.fam")

# Read the .fam file
fam_data <- read.table(fam_file_path, header = FALSE, stringsAsFactors = FALSE)

# Extract the family names from the first column
populations <- unique(fam_data$V1)

# Remove "TER" from the populations vector
# populations <- populations[populations != "TER"]

# Determine the number of unique populations
num_populations <- length(unique(populations))

# Fetch colors accordingly
colors_set3 <- brewer.pal(min(12, num_populations), "Set3")
colors_pastel2 <- brewer.pal(min(8, num_populations - length(colors_set3)), "Pastel2")
colors_paired <- brewer.pal(min(12, num_populations - length(colors_set3) - length(colors_pastel2)), "Paired")

# Combine the colors
colors <- c(colors_set3, colors_pastel2, colors_paired)

# Ensure we're only taking as many colors as there are populations
colors <- colors[1:num_populations]

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)


# Initialize an empty list to store data frames
data_frames <- list()

#
# Read data from each population file and store it in the list
for (pop in populations) {
  file_path <- paste("output/populations/ld_chr3/all_pops.", pop, sep = "")
  data <- read.table(file_path)
  data$population <- pop  # Add a column for population name
  data_frames[[pop]] <- data
}

# Combine all data frames into a single data frame
combined_data <- do.call(rbind, data_frames)

# Create a named vector for populations and their colors
color_mapping <- setNames(colors, populations)

# Calculate half distances
half_distances <- combined_data |>
  group_by(population) |>
  mutate(max_r2 = max(V2)) |>
  filter(V2 <= max_r2 / 2) |>
  arrange(V1) |>
  slice(1) |>
  select(population, half_distance = V1)

# Calculate the maximum V2 value for each population
max_values <- combined_data |>
  group_by(population) |>
  summarize(max_V2 = max(V2))

# Merge the maximum V2 values with the half_distances dataframe
half_distances <- merge(half_distances, max_values, by = "population")

# Create the ggplot
p <- ggplot(combined_data, aes(x = V1 / 1000, y = V2, group = population, color = population)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, span = 0.3, color = "black", linewidth = 0.5) +
  geom_vline(data = half_distances, aes(xintercept = half_distance / 1000), color = "blue", linetype = "dashed") +
  geom_text_repel(data = half_distances, aes(x = half_distance / 1000 + 130, y = max_V2, label = paste0(round(half_distance / 1000, 1), "Kb")), 
            color = "blue", vjust = -1, size = 3) +
  labs(
    title = "",
    x = "Distance(Kb)",
    y = expression(r^2)
  ) +
  scale_color_manual(values = color_mapping) +
  scale_y_continuous(labels = label_comma(accuracy = 0.01)) +
  scale_x_continuous(labels = label_comma()) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(face = "bold", size = 14),
    axis.title.y = element_text(face = "bold", size = 14),
    strip.text = element_text(face = "bold")
  ) +
  facet_wrap(~ population, scales = "free_y", ncol = 3) +
  coord_cartesian(xlim = c(0, 300))

p

ggsave("output/populations/ld_chr1/decay_chr3.pdf", plot = p, width = 6, height = 10)
```

Save the data to use later
```{r}
saveRDS(combined_data, here(
  "output", "populations", "ld_chr3", "chr3.rds"
))
```

## 3. Plot comparying chromosomes

Clean env and memory
```{r}
# Remove all objects from the environment
rm(list = ls())

# Run the garbage collector to free up memory
gc()
```

Create data frame with the data from each chromosome (I created an Excel spreadsheet with it)
```{r}
# Sample data
data <- data.frame(
  population = c("ARA", "BEL", "BHO", "BOA", "BRA", "CAM", "CHA", "CUI", "FOR", 
                 "FOZ", "GOI", "IRE", "ITA", "JOA", "MAC", "MAE", "MAN", "MAR", 
                 "MOS", "NAT", "PAL", "PAR", "POR", "QUA", "RBR", "REC", "RIB", 
                 "RIO", "SAL", "SAO", "SLU", "UBE", "VIT"),
  Chr1 = c(6, 24, 17, 12, 24, 13, 6, 24, 26, 6, 8, 4, 8, 27, 17, 13, 12, 4, 8, 13, 14, 8, 13, 12, 30, 19, 17, 22, 17, 26, 24, 19, 6),
  Chr2 = c(58, 34, 62, 52, 29, 58, 27, 49, 46, 27, 49, 58, 29, 24, 13, 27, 29, 29, 15, 58, 24, 46, 29, 58, 27, 15, 27, 65, 65, 65, 49, 24, 53),
  Chr3 = c(10, 8, 10, 8, 16, 16, 10, 38, 5, 10, 16, 8, 16, 8, 16, 10, 14, 16, 10, 8, 16, 8, 30, 8, 16, 8, 10, 16, 10, 16, 16, 10, 10)
)


# Convert data from wide to long format
data_long <- gather(data, key = "chr", value = "value", -population)
```



Make one plot
```{r, fig.height=8, fig.width=5}
# Define a custom color palette
custom_palette <- c(
  "Chr1" = "#edb975", 
  "Chr2" = "#c1f5ff", 
  "Chr3" = "#ff72f3"
)

# Reordering the levels of the chr factor
data_long$chr <- factor(data_long$chr, levels = c("Chr3", "Chr2", "Chr1"))

# source the plotting function
source(here("scripts", "analysis", "my_theme2.R"))

# Plotting half_distance with borders and spaced bars
ggplot(data_long, aes(x = population, y = value, fill = chr)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black", width = 0.7) +
  labs(title = "", y = "Half Distance (kb)", x = "Population") +
  geom_text(aes(label = round(value, 0)), position = position_dodge(width = 0.8), vjust = 0.5, hjust = -0.2, size = 4) +
  my_theme() +
  coord_flip() +
  scale_fill_manual(values = custom_palette, name = "Chromosome", breaks = c("Chr1", "Chr2", "Chr3")) +
  theme(legend.position = "top",
        plot.margin = margin(t = 10, r = 30, b = 10, l = 10, unit = "pt"))

# save it
# ggsave("output/populations/ld_chr1/decay_3_chrm.pdf", width = 5, height = 8)
```



Import sample locations
```{r}
sampling_loc <- readRDS(here("output", "populations", "cities.rds"))
head(sampling_loc)
```

```{r}
head(data_long)
```


```{r}
# Join with sampling_loc to get sampling localities
distance <- data_long |>
  left_join(sampling_loc, by = c("population" = "pop"))
head(distance)
```


Add the name of the city/countries to the plot
```{r, fig.height=14, fig.width=6}
# Calculate the mean half distance for each population
mean_values <- aggregate(value ~ population, distance, mean)

# Creating the label with population, city, and country for the y-axis
distance$pop_city_country_label <- paste(distance$population, "\n", distance$city, "\n(", distance$region, ")", sep = "")

# Sorting by Country, then City, and then by Population to ensure populations from the same country (and city) are plotted together
distance <- distance %>% arrange(region, city, population)

# Adjusting the factor levels for plotting in the desired order
distance$pop_city_country_label <- fct_inorder(distance$pop_city_country_label)

# Merge
mean_values <- mean_values %>%
  left_join(select(distance, population, pop_city_country_label), by = "population")

# Plotting the data
ggplot(distance, aes(x = pop_city_country_label, y = value, fill = chr)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black", width = 0.7) +
  labs(title = "", y = "Half Distance (kb)", x = "") +
  geom_text(aes(label = round(value, 0)), position = position_dodge(width = 0.8), vjust = 0.5, hjust = -0.2, size = 3.5) +
  # geom_text(data = mean_values, aes(x = pop_city_country_label, y = 150, label = sprintf(" %.0f", value)), color = "red", vjust = -0.5, size = 4, inherit.aes = FALSE) +
  my_theme() +
  coord_flip() +
  labs(title = "", y = "Half Distance (kb)", x = "Population") +
  scale_fill_manual(values = custom_palette, name = "Chromosome", breaks = c("Chr1", "Chr2", "Chr3")) +
  theme(legend.position = "top",
        plot.margin = margin(t = 10, r = 30, b = 10, l = 10, unit = "pt"),
        axis.text.y = element_text(angle = 0, hjust = 1))

# ggsave("output/populations/ld_chr1/decay_3_chrm_plus_mean.pdf", width = 5, height = 8)
```


Add biome and sort by region
```{r, fig.height=12, fig.width=6}
# Calculate the mean half distance for each population
mean_values <- aggregate(value ~ population, distance, mean)

# Creating the label with population, city, and biome for the y-axis
distance$pop_city_biome_label <- paste(distance$population, "\n", distance$city, "\n(", distance$biome, ")", sep = "")

# Sorting by Region, then City, and then by Population to ensure populations from the same region (and city) are plotted together
distance <- distance %>% arrange(region, city, population)

# Adjusting the factor levels for plotting in the desired order
distance$pop_city_biome_label <- fct_inorder(distance$pop_city_biome_label)

# Merge mean values with the labels
mean_values <- mean_values %>%
  left_join(select(distance, population, pop_city_biome_label), by = "population")

# Plotting the data
ggplot(distance, aes(x = pop_city_biome_label, y = value, fill = chr)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black", width = 0.7) +
  labs(title = "", y = "Half Distance (kb)", x = "") +
  geom_text(aes(label = round(value, 0)), position = position_dodge(width = 0.8), vjust = 0.5, hjust = -0.2, size = 3.5) +
  # geom_text(data = mean_values, aes(x = pop_city_biome_label, y = 70, label = sprintf(" %.0f", value)), color = "red", vjust = -0.5, size = 4, inherit.aes = FALSE) +
  my_theme() +
  coord_flip() +
  labs(title = "", y = "Half Distance (kb)", x = "Population") +
  scale_fill_manual(values = custom_palette, name = "Chromosome", breaks = c("Chr1", "Chr2", "Chr3")) +
  theme(legend.position = "top",
        plot.margin = margin(t = 10, r = 30, b = 10, l = 10, unit = "pt"),
        axis.text.y = element_text(angle = 0, hjust = 1, size = 8, color = "black"))

ggsave("output/populations/ld_chr1/decay_3_chrm_plus_mean.pdf", width = 6, height = 14)
```
To annotate the region on Adobe illustrator
```{r}
# Extracting the first population for each region
first_population_per_region <- distance %>%
  group_by(region) %>%
  slice(1) %>%
  select(region, population)

# Extracting the last population for each region
last_population_per_region <- distance %>%
  group_by(region) %>%
  slice(n()) %>%
  select(region, population)

# Combining both dataframes for a complete list
combined_populations <- rbind(first_population_per_region, last_population_per_region)

print(combined_populations |>
        arrange(region))

```

```{r}
dist_table <- distance |>
  dplyr::select(
    population, city, region, biome, chr, value,
  )

dist_table_condensed <- dist_table %>%
  spread(key = chr, value = value) %>%
  select(population, city, region, biome, Chr1, Chr2, Chr3)


# Create table
ft <- flextable::flextable(dist_table_condensed)


# Apply zebra striping with bg
ft <- flextable::theme_zebra(ft)

# Show it
ft

# Create a new Word document
doc <- read_docx()

# Add the flextable
doc <- body_add_flextable(doc, value = ft)

# Save the document to a file
# Define the path for saving the Word document
file_path <- here("output", "populations", "ld_chr1", "decay_3_chrm.docx")

print(doc, target = file_path)
```

